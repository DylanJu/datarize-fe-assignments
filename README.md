## 프로젝트 구조

```
├──src/
│   ├── App.tsx            # 메인 App 컴포넌트
│   ├── main.tsx           # 애플리케이션 진입점
│   ├── api/               # API 클라이언트 관련
│   │   ├── index.ts       # API 호출 함수들
│   │   ├── queryClient.ts # React Query 클라이언트 설정
│   │   └── type.ts        # API 타입 정의
│   ├── components/        # 재사용 가능한 컴포넌트들
│   │   ├── AppTitle.tsx   # 애플리케이션 제목
│   │   ├── CustomersSection.tsx # 고객 목록 섹션
│   │   ├── PurchaseFrequencySection.tsx # 구매 빈도 차트 섹션
│   │   ├── CustomerPurchases.tsx # 고객 상세 구매 내역 모달
│   │   ├── Modal.tsx      # 모달 컴포넌트
│   │   ├── Loader.tsx     # 로딩 스피너
│   │   └── ErrorBoundary.tsx # 에러 경계 처리
│   ├── hook/              # 커스텀 훅들
│   │   ├── useDateRange.ts # 날짜 범위 관리
│   │   └── useDebouncedInputValue.ts # 검색 입력 디바운스
│   ├── query/             # React Query 관련
│   │   ├── query-options/ # 쿼리 옵션 설정
│   │   └── use*.ts        # 쿼리 훅들
│   ├── style/             # 스타일 관리
│   │   ├── global.css.ts  # 전역 스타일
│   │   └── theme.css.ts   # 테마 스타일
│   ├── util/              # 유틸리티 함수들
│   ├── constant/          # 상수 정의
│   └── fixture/           # MSW 테스트 데이터
├── package.json
├── vite.config.ts
└── tsconfig.json
```

### 추가한 기술 스택

- **@tanstack/react-query**

  - 서버 상태 관리와 캐싱, 데이터 동기화를 효율적으로 처리하기 위해 선택했습니다. API 호출 시 로딩 상태와 에러 처리를 자동으로 관리하며, 백그라운드 업데이트와 캐시 무효화 기능을 제공합니다.

- **@vanilla-extract/css**

  - 타입 안전성을 보장하는 CSS-in-JS 솔루션으로, 컴파일 타임에 스타일을 생성하여 런타임 오버헤드가 없습니다. 스타일 변수와 테마 값들이 TypeScript로 타입 체크되어 오타나 잘못된 값 사용을 미리 방지할 수 있고, 제가 익숙해서 선택했습니다.

- **Recharts**

  - 가장 대중적인 리액트 차트 라이브러리를 선택했습니다.

- **MSW (Mock Service Worker)**

  - 실제 네트워크 수준에서 API 요청을 가로채어 모킹하므로, 개발 환경과 테스트 환경에서 일관된 API 응답을 제공합니다. 백엔드 API와 독립적으로 프론트엔드 개발과 테스트를 진행할 수 있습니다.

- **Storybook**

  - 컴포넌트를 독립적으로 개발하고 테스트할 수 있는 환경을 제공하여, UI 컴포넌트의 품질을 향상시킵니다. Play function을 통해 컴포넌트 테스트(UI, 유저 인터랙션)를 눈으로 확인할 수 있어 테스트를 파악하기 용이합니다.

- **Vitest**
  - Jest와 호환되는 API를 제공하면서도 더 나은 성능과 TypeScript 지원을 제공합니다. Storybook과 궁합이 잘 맞습니다.

### 주요 코드설명

1. API
   API 호출 함수와 타입을 query, 컴포넌트 등 다른 코드와 분리하면, 각 레이어의 역할이 명확해져 코드의 구조가 깔끔해집니다. API 관련 로직이 한 곳에 모여 있어 재사용과 유지보수가 쉬워지고, 실제 화면/비즈니스 로직과 독립적으로 테스트 및 수정이 가능합니다.

2. query 훅과 query options
   query 훅과 query options를 분리하면, 데이터 패칭 로직과 쿼리의 옵션(파라미터, 캐싱, 조건 등)을 독립적으로 관리할 수 있어 코드의 재사용성과 확장성이 높아집니다. 여러 컴포넌트에서 동일한 쿼리 옵션을 공유하거나, 옵션만 따로 수정해 다양한 상황에 대응할 수 있어 유지보수와 테스트가 편리해집니다.

3. 컴포넌트 테스트
   UI에 표기되는 요소와 유저인터랙션은 스토리북으로 테스트를 작성했습니다. 렌더링된 요소들을 눈으로 보며 테스트를 작성하고 검증할 수 있어 UI 코드에 대한 자신감을 가질 수 있습니다.

4. 에러바운더리
   대시보드의 각 섹션을 에러바운더리로 감싸, 일부 API가 실패해도 전체 화면이 깨지지 않도록 했습니다. 또한 query reset 기능을 통해 실패한 섹션만 개별적으로 복구할 수 있게 구현했습니다.

5. 로딩 UI 처리
   대시보드는 여러 섹션이 각각의 API를 호출하며, 날짜나 검색어 변경 시 각 섹션별로 리페치가 일어나는 구조입니다. 전체 페이지가 한 번에 로딩되는 것을 방지하고, 각 섹션이 독립적으로 로딩 상태를 관리할 수 있도록 Suspense 대신 섹션별 로딩 UI를 구현했습니다. 이를 통해 사용자 경험을 저해하지 않으면서도 각 API의 비동기 처리를 효율적으로 관리할 수 있습니다.

### 커밋 설명

커밋은 의미있는 작업 단위로 작성하고, 태그를 이용해 목적을 파악하기 쉽게했습니다.

- 주요 태그
  - feat: 기능 추가
  - refactor: 기능 변경 없이 코드 리팩토링
  - config: 설정 변경 (라이브러리, 린트 등)
  - deps: 패키지 설치
